import traceback
import logging
import queue
import threading
import os
import re
import time
import math
import asyncio
import logging
import traceback
import tkinter as tk
from pathlib import Path
from datetime import datetime
from queue import Queue
from threading import Thread, Event
from typing import Any, Dict, List
from app.video_creator import crear_video_desde_imagenes
from moviepy import *
from prompt_generator import GEMINI_AVAILABLE, generar_prompts_con_gemini
from image_generator import generar_imagen_con_replicate, REPLICATE_AVAILABLE

# Importar el generador de voz en off
try:
    from tts_generator import create_voiceover_from_script, OUTPUT_FORMAT
except ImportError:
    print("Advertencia: No se pudo importar 'create_voiceover_from_script' o 'OUTPUT_FORMAT'.")
    print("Asegúrate de que el archivo tts_generator.py esté accesible.")
    # Define valores por defecto si la importación falla
    async def create_voiceover_from_script(script_path, output_path, voice=None):
        print(f"Simulando: Generando audio desde '{script_path}' a '{output_path}'")
        # En una ejecución real, esto crearía el archivo
        Path(output_path).touch()  # Crea un archivo vacío como marcador
        return output_path  # Devuelve la ruta simulada
    OUTPUT_FORMAT = "mp3"

# Importar generador de subtítulos
try:
    from subtitles import generate_srt_with_whisper, WHISPER_AVAILABLE
    if WHISPER_AVAILABLE:
        try:
            from faster_whisper import WhisperModel
        except ImportError:
            print("Advertencia: No se pudo importar WhisperModel a pesar de que WHISPER_AVAILABLE es True")
            WHISPER_AVAILABLE = False
except ImportError:
    print("Advertencia: No se pudo importar 'generate_srt_with_whisper' o 'WHISPER_AVAILABLE'.")
    print("Asegúrate de que el archivo subtitles.py esté accesible.")
    WHISPER_AVAILABLE = False

class BatchTTSManager:
    """Gestor de procesamiento por lotes para la generación de voz en off."""
    
    def __init__(self, root, default_voice="es-MX-JorgeNeural"):
        """
        Inicializa el gestor de procesamiento por lotes.
        
        Args:
            root: La ventana principal de Tkinter
            default_voice: La voz predeterminada para la generación de TTS
        """
        self.root = root
        self.default_voice = default_voice
        
        # Configuración de directorios
        self.project_base_dir = Path("proyectos_video")
        self.project_base_dir.mkdir(parents=True, exist_ok=True)
        
        # Cola de trabajos y contador
        self.job_queue = queue.Queue()
        self.jobs_in_gui = {}  # Diccionario para rastrear trabajos y sus IDs en el Treeview
        self.job_counter = 0  # Para IDs únicos
        
        # Estado del worker
        self.worker_running = False
        self.worker_thread = None
        
        # Variables para la interfaz
        self.tree_queue = None  # Se inicializará cuando se cree la interfaz
    
    def sanitize_filename(self, filename):
        """Limpia un string para usarlo como nombre de archivo/carpeta seguro."""
        # Quitar caracteres inválidos
        sanitized = re.sub(r'[\\/*?:"<>|]', "", filename)
        # Reemplazar espacios con guiones bajos
        sanitized = sanitized.replace(" ", "_")
        # Limitar longitud
        return sanitized[:100]  # Limitar a 100 caracteres
    
    def add_project_to_queue(self, title, script, voice=None, video_settings=None):
        """
        Añade un nuevo proyecto a la cola de procesamiento.
        
        Args:
            title: Título del proyecto
            script: Texto del guion para la voz en off
            voice: Voz a utilizar (opcional, usa default_voice si no se especifica)
            video_settings: Diccionario con ajustes para la creación del video
        
        Returns:
            bool: True si se añadió correctamente, False en caso contrario
        """
        if not title:
            messagebox.showerror("Error", "Por favor, introduce un título para el proyecto.")
            return False
        
        if not script:
            messagebox.showerror("Error", "Por favor, introduce un guion para el proyecto.")
            return False
        
        # Crear carpeta de proyecto
        safe_title = self.sanitize_filename(title)
        project_folder = self.project_base_dir / safe_title
        
        try:
            project_folder.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            messagebox.showerror("Error", f"No se pudo crear la carpeta del proyecto:\n{project_folder}\nError: {e}")
            return False
        
        # Guardar guion
        script_file_path = project_folder / "guion.txt"
        try:
            with open(script_file_path, "w", encoding="utf-8") as f:
                f.write(script)
        except IOError as e:
            messagebox.showerror("Error", f"No se pudo guardar el guion:\n{script_file_path}\nError: {e}")
            return False
        
        # Crear y añadir trabajo a la cola
        self.job_counter += 1
        job_id = f"job_{self.job_counter}"
        
        job_data = {
            'id': job_id,
            'titulo': title,  # Guardamos el título original para mostrar
            'guion_path': str(script_file_path),
            'carpeta_salida': str(project_folder),
            'voz': voice or self.default_voice,
            'estado': 'Pendiente',
            'tiempo_inicio': None,
            'tiempo_fin': None,
            # Guardar ajustes para la creación del video
            'video_settings': video_settings or {}
        }
        
        # Guardar configuración del proyecto en un archivo JSON
        settings_file_path = project_folder / "settings.json"
        try:
            import json
            with open(settings_file_path, "w", encoding="utf-8") as f:
                # Asegurarse de que los datos sean serializables
                serializable_settings = {}
                if video_settings:
                    serializable_settings = video_settings.copy()
                    # Convertir rutas a strings si es necesario
                    for key, value in serializable_settings.items():
                        if isinstance(value, Path):
                            serializable_settings[key] = str(value)
                        elif isinstance(value, list) and value and isinstance(value[0], Path):
                            serializable_settings[key] = [str(p) for p in value]
                json.dump(serializable_settings, f, indent=4, ensure_ascii=False)
            print(f"Configuración guardada en {settings_file_path}")
        except Exception as e:
            print(f"Error al guardar la configuración: {e}")
            # Continuamos aunque falle el guardado de la configuración
        
        self.job_queue.put(job_data)
        
        # Añadir a la GUI (Treeview) si ya existe
        if self.tree_queue:
            self.tree_queue.insert("", tk.END, iid=job_id, values=(title, 'Pendiente', '-'))
            self.jobs_in_gui[job_id] = job_data
        
        print(f"Proyecto '{title}' añadido a la cola (ID: {job_id}).")
        return True
    
    def add_existing_project_to_queue(self, title, script, project_folder, voice=None, video_settings=None):
        """
        Añade un proyecto existente a la cola de procesamiento.
        
        Args:
            title: Título del proyecto
            script: Texto del guion para la voz en off
            project_folder: Ruta a la carpeta del proyecto existente
            voice: Voz a utilizar (opcional, usa default_voice si no se especifica)
            video_settings: Diccionario con ajustes para la creación del video
        
        Returns:
            str: ID del trabajo si se añadió correctamente, None en caso contrario
        """
        if not title or not script or not project_folder:
            print("Error: Título, guion y carpeta del proyecto son obligatorios")
            return None
        
        # Convertir a Path si es un string
        if isinstance(project_folder, str):
            project_folder = Path(project_folder)
        
        # Verificar que la carpeta existe
        if not project_folder.exists() or not project_folder.is_dir():
            print(f"Error: La carpeta del proyecto {project_folder} no existe")
            return None
        
        # Usar la voz predeterminada si no se especifica
        if not voice:
            voice = self.default_voice
        
        # Generar un ID único para el trabajo
        self.job_counter += 1
        job_id = f"job_{self.job_counter}"
        
        # Crear datos del trabajo
        job_data = {
            'id': job_id,
            'titulo': title,
            'guion_path': str(project_folder / "guion.txt"),
            'carpeta_salida': str(project_folder),
            'voz': voice,
            'estado': 'Cargado',
            'tiempo_inicio': None,
            'tiempo_fin': None,
            'script': script  # Guardamos una copia del script en memoria
        }
        
        # Verificar si existen archivos de audio, subtítulos, prompts e imágenes
        audio_path = project_folder / f"voz.{OUTPUT_FORMAT}"
        if audio_path.exists():
            job_data['archivo_voz'] = str(audio_path)
            job_data['estado'] = 'Audio Existente'
        
        subtitles_path = project_folder / "subtitulos.srt"
        if subtitles_path.exists():
            job_data['archivo_subtitulos'] = str(subtitles_path)
            job_data['aplicar_subtitulos'] = True
        
        prompts_path = project_folder / "prompts.txt"
        if prompts_path.exists():
            # Intentar cargar los prompts desde el archivo
            try:
                # Leer el archivo de prompts y reconstruir la estructura
                with open(prompts_path, "r", encoding="utf-8") as f:
                    prompts_content = f.read()
                
                # Procesar el contenido para extraer los prompts
                # Este es un enfoque simple, podría necesitar ajustes según el formato exacto
                import re
                
                # Buscar patrones de segmentos y prompts
                segments = re.findall(r"Segmento Guion \(ES\):\n(.+?)\n\n", prompts_content, re.DOTALL)
                prompts = re.findall(r"Prompt Generado \(EN\):\n(.+?)\n=", prompts_content, re.DOTALL)
                
                if segments and prompts and len(segments) == len(prompts):
                    prompts_data = []
                    for i in range(len(segments)):
                        prompts_data.append({
                            'segmento_es': segments[i].strip(),
                            'prompt_en': prompts[i].strip()
                        })
                    
                    job_data['prompts_data'] = prompts_data
                    job_data['num_imagenes'] = len(prompts_data)
                    print(f"Cargados {len(prompts_data)} prompts desde {prompts_path}")
            except Exception as e:
                print(f"Error al cargar prompts desde {prompts_path}: {e}")
        
        # Buscar imágenes en la carpeta de imágenes
        images_folder = project_folder / "imagenes"
        if images_folder.exists() and images_folder.is_dir():
            # Buscar archivos de imagen
            image_extensions = [".jpg", ".jpeg", ".png"]
            images = []
            for ext in image_extensions:
                images.extend(list(images_folder.glob(f"*{ext}")))
            
            if images:
                job_data['imagenes_generadas'] = [str(img) for img in images]
                print(f"Encontradas {len(images)} imágenes en {images_folder}")
        
        # Agregar configuración de video si se proporciona
        if video_settings:
            job_data['video_settings'] = video_settings
        
        # Añadir a la GUI (Treeview) si ya existe
        if self.tree_queue:
            self.tree_queue.insert("", tk.END, iid=job_id, values=(title, job_data['estado'], '-'))
            self.jobs_in_gui[job_id] = job_data
        
        print(f"Proyecto existente '{title}' cargado en la cola (ID: {job_id}).")        
        return job_id
    
    def start_worker(self):
        """Inicia el hilo trabajador si no está en ejecución."""
        if not self.worker_running:
            self.worker_running = True
            self.worker_thread = threading.Thread(target=self._process_queue, args=(None,), daemon=True)
            self.worker_thread.start()
            print("Worker de cola iniciado.")
    
    def stop_worker(self):
        """Detiene el hilo trabajador (completará el trabajo actual)."""
        self.worker_running = False
        print("Worker de cola detenido. Completará el trabajo actual antes de terminar.")
    
    def _process_queue(self, whisper_model_loaded=None):
        """Procesa los trabajos en la cola de forma secuencial."""
        while self.worker_running:
            try:
                # Esperar un trabajo con timeout para poder comprobar worker_running
                try:
                    job = self.job_queue.get(timeout=1)
                except queue.Empty:
                    # No hay trabajos, seguir esperando
                    continue
                
                job_id = job['id']
                title = job['titulo']
                script_path = job['guion_path']
                output_folder = Path(job['carpeta_salida'])
                voice = job['voz']
                audio_output_path = str(output_folder / f"voz.{OUTPUT_FORMAT}")
                
                # Actualizar estado y tiempo de inicio
                job['tiempo_inicio'] = time.time()
                self.update_job_status_gui(job_id, "Generando Audio...", "-")
                
                print(f"Procesando trabajo {job_id}: '{title}'")
                
                final_audio_path = None
                success_tts = False
                error_msg = ""
                
                try:
                    # Ejecutar la corutina create_voiceover_from_script
                    final_audio_path = asyncio.run(create_voiceover_from_script(
                        script_path=script_path,
                        output_audio_path=audio_output_path,
                        voice=voice
                    ))
                    
                    # Calcular tiempo transcurrido para la generación de audio
                    audio_tiempo_fin = time.time()
                    audio_tiempo_transcurrido = audio_tiempo_fin - job['tiempo_inicio']
                    audio_tiempo_formateado = f"{int(audio_tiempo_transcurrido // 60)}m {int(audio_tiempo_transcurrido % 60)}s"
                    
                    if final_audio_path and Path(final_audio_path).is_file():
                        print(f"Audio generado para {job_id}: {final_audio_path}")
                        # Actualizar el job con la ruta del audio generado
                        job['archivo_voz'] = final_audio_path
                        success_tts = True
                        
                        # --- Generar subtítulos con Whisper ---
                        if WHISPER_AVAILABLE:
                            self.update_job_status_gui(job_id, "Audio OK. Generando SRT...", audio_tiempo_formateado)
                            
                            # Buscar el modelo Whisper en la GUI
                            whisper_model = None
                            try:
                                # Intentar obtener el modelo Whisper directamente
                                if WHISPER_AVAILABLE:
                                    # Primero, buscar en la instancia actual de la aplicación
                                    app_instance = None
                                    for widget in self.root.winfo_children():
                                        if hasattr(widget, 'whisper_model'):
                                            app_instance = widget
                                            break
                                    
                                    if app_instance and hasattr(app_instance, 'whisper_model') and app_instance.whisper_model is not None:
                                        print("Usando modelo Whisper de la instancia de la aplicación")
                                        whisper_model = app_instance.whisper_model
                                    else:
                                        # Si no se encuentra en la GUI, crear un nuevo modelo
                                        print("No se encontró modelo Whisper en la GUI. Creando uno nuevo...")
                                        try:
                                            from faster_whisper import WhisperModel
                                            # Usar un modelo base por defecto
                                            whisper_model = WhisperModel("base", device="cpu", compute_type="int8")
                                            print("Modelo Whisper creado exitosamente")
                                        except Exception as e_model:
                                            print(f"Error al crear modelo Whisper: {e_model}")
                            except Exception as e_gui:
                                print(f"Error al buscar modelo Whisper: {e_gui}")
                            
                            # Generar subtítulos si tenemos el modelo
                            srt_output_path = str(output_folder / "subtitulos.srt")
                            srt_success = False
                            
                            if whisper_model:
                                try:
                                    # Obtener configuración del modelo Whisper de la GUI
                                    whisper_language = "es"  # Valor por defecto
                                    word_timestamps = True  # Valor por defecto
                                    
                                    # Intentar obtener configuración de la GUI
                                    if hasattr(app_instance, 'whisper_language') and hasattr(app_instance.whisper_language, 'get'):
                                        whisper_language = app_instance.whisper_language.get()
                                    
                                    if hasattr(app_instance, 'whisper_word_timestamps') and hasattr(app_instance.whisper_word_timestamps, 'get'):
                                        word_timestamps = app_instance.whisper_word_timestamps.get()
                                    
                                    # Obtener la opción de subtítulos en mayúsculas
                                    uppercase = False
                                    if hasattr(app_instance, 'subtitles_uppercase') and hasattr(app_instance.subtitles_uppercase, 'get'):
                                        uppercase = app_instance.subtitles_uppercase.get()
                                    
                                    print(f"Generando subtítulos con idioma: {whisper_language}, timestamps por palabra: {word_timestamps}, mayúsculas: {uppercase}")
                                    
                                    # Generar subtítulos con la configuración
                                    srt_success = generate_srt_with_whisper(
                                        whisper_model,
                                        final_audio_path,
                                        srt_output_path,
                                        language=whisper_language,
                                        word_timestamps=word_timestamps,
                                        uppercase=uppercase
                                    )
                                except Exception as e_srt:
                                    print(f"Error al generar subtítulos: {e_srt}")
                            else:
                                print("No se encontró el modelo Whisper para generar subtítulos.")
                            
                            # Actualizar el job con la información de subtítulos
                            if srt_success:
                                self.update_job_status_gui(job_id, "Audio y SRT OK", audio_tiempo_formateado)
                                job['archivo_subtitulos'] = srt_output_path
                                job['aplicar_subtitulos'] = True
                                print(f"Subtítulos generados exitosamente en: {srt_output_path}")

                                # --- NUEVO: Generación de Prompts ---
                                if GEMINI_AVAILABLE and srt_success:
                                    self.update_job_status_gui(job_id, "Audio/SRT OK. Generando Prompts...")
                                    try:
                                        # Leer guion
                                        with open(script_path, 'r', encoding='utf-8') as f:
                                            script_content = f.read()

                                        # Calcular número de imágenes usando la función optimizada
                                        temp_audio_clip = AudioFileClip(final_audio_path)
                                        audio_duration = temp_audio_clip.duration
                                        temp_audio_clip.close()
                                        
                                        # Imprimir todos los parámetros del job para depuración
                                        print("\nParámetros del trabajo:")
                                        for k, v in job.items():
                                            if k != 'script' and k != 'prompts_data':  # Evitar imprimir textos largos
{{ ... }}
                                                print(f"  {k}: {v}")
                                        
                                        # Obtener parámetros relevantes del job
                                        # Intentar obtener la duración de imagen de diferentes fuentes posibles
                                        duracion_por_imagen = None
                                        
                                        # 1. Intentar obtener de video_settings.duracion_img (valor de la interfaz gráfica)
                                        if 'video_settings' in job and isinstance(job['video_settings'], dict) and 'duracion_img' in job['video_settings']:
                                            duracion_por_imagen = job['video_settings'].get('duracion_img')
                                            print(f"Duración obtenida de video_settings.duracion_img: {duracion_por_imagen}")
                                        
                                        # 2. Intentar obtener de settings.duracion_img
                                        elif 'settings' in job and isinstance(job['settings'], dict) and 'duracion_img' in job['settings']:
                                            duracion_por_imagen = job['settings'].get('duracion_img')
                                            print(f"Duración obtenida de settings.duracion_img: {duracion_por_imagen}")
                                        
                                        # 3. Intentar obtener directamente de duracion_img
                                        elif 'duracion_img' in job:
                                            duracion_por_imagen = job.get('duracion_img')
                                            print(f"Duración obtenida de duracion_img: {duracion_por_imagen}")
                                        
                                        # 4. Usar valor predeterminado si no se encuentra
                                        else:
                                            duracion_por_imagen = 20.0  # Valor predeterminado igual al de la interfaz gráfica
                                            print(f"Usando duración predeterminada: {duracion_por_imagen}")
                                        
                                        # Asegurarse de que sea un número válido
                                        try:
                                            duracion_por_imagen = float(duracion_por_imagen)
                                        except (ValueError, TypeError):
                                            duracion_por_imagen = 15.0
                                            print(f"Error al convertir duración, usando valor predeterminado: {duracion_por_imagen}")
                                        
                                        # Obtener parámetros de configuración desde video_settings
                                        video_settings_job = job.get('video_settings', {})
                                        
                                        # Obtener configuración de transiciones
                                        aplicar_transicion = video_settings_job.get('aplicar_transicion', False)
                                        duracion_transicion_setting = video_settings_job.get('duracion_transicion', 1.0)
                                        
                                        # Usar la duración de transición solo si se aplican
                                        duracion_transicion_usada = duracion_transicion_setting if aplicar_transicion else 0.0
                                        
                                        # Obtener la preferencia de respetar duración exacta
                                        respetar_duracion_exacta_setting = video_settings_job.get('respetar_duracion_exacta', True)
                                        
                                        # Obtener configuración de fade in/out
                                        fade_in = video_settings_job.get('duracion_fade_in', 2.0)
                                        fade_out = video_settings_job.get('duracion_fade_out', 2.0)
                                        
                                        print(f"\n--- Calculando Imágenes Óptimas para Job {job_id} ---")
                                        print(f"Audio Duration: {audio_duration:.2f}s")
                                        print(f"Duración por Imagen (config): {duracion_por_imagen:.2f}s")
                                        print(f"Aplicar Transición: {aplicar_transicion}")
                                        print(f"Duración Transición (config): {duracion_transicion_setting:.2f}s")
                                        print(f"Respetar Duración Exacta (config): {respetar_duracion_exacta_setting}")
                                        print(f"Fade In: {fade_in:.2f}s, Fade Out: {fade_out:.2f}s")
                                        print(f"----------------------------------------------------\n")
                                        
                                        # Calcular el número óptimo de imágenes
                                        num_imagenes_necesarias, tiempos_imagenes = self.calcular_imagenes_optimas(
                                            audio_duration=audio_duration,
                                            duracion_por_imagen=duracion_por_imagen,
                                            duracion_transicion=duracion_transicion_usada,
                                            aplicar_transicion=aplicar_transicion,
                                            fade_in=fade_in,
                                            fade_out=fade_out,
                                            respetar_duracion_exacta=respetar_duracion_exacta_setting
                                        )
                                        
                                        # Guardar los tiempos de las imágenes para usarlos en la generación de video
                                        job['tiempos_imagenes'] = tiempos_imagenes
                                        job['num_imagenes'] = num_imagenes_necesarias  # Actualizar el número de imágenes en el job
                                        
                                        # Verificar si hay información de repetición del último clip
                                        for clip in tiempos_imagenes:
                                            if 'repetir' in clip and clip['repetir']:
                                                job['repetir_ultimo_clip'] = True
                                                job['tiempo_repeticion_ultimo_clip'] = clip['tiempo_repeticion']
                                                print(f"Configurando repetición del último clip durante {clip['tiempo_repeticion']:.2f}s")
                                                break
                                        
                                        # Asegurar que los parámetros estén en el job para la creación del video
                                        if 'video_settings' not in job:
                                            job['video_settings'] = {}
                                        job['video_settings']['aplicar_transicion'] = aplicar_transicion
                                        job['video_settings']['duracion_transicion'] = duracion_transicion_usada

                                        # Llamar a la función de generación de prompts
                                        # Obtener el estilo de prompts seleccionado del diccionario 'video_settings' dentro del job
                                        video_settings_del_job = job.get('video_settings', {})  # Obtener el diccionario de ajustes, o uno vacío si no existe
                                        estilo = video_settings_del_job.get('estilo_imagenes', 'default')  # Obtener el estilo de ese diccionario
                                        
                                        # Imprimir información detallada para depuración
                                        print(f"\n\n=== INFORMACIÓN DE ESTILO DE PROMPTS ===\n")
                                        print(f"Estilo seleccionado en interfaz: '{estilo}'")
                                        print(f"Nombre del estilo: '{video_settings_del_job.get('nombre_estilo', 'No especificado')}'")
                                        print(f"Ajustes completos: {video_settings_del_job}")
                                        
                                        # Verificar que el estilo existe en el gestor de prompts
                                        try:
                                            from prompt_manager import PromptManager
                                            prompt_manager = PromptManager()
                                            estilos_disponibles = prompt_manager.get_prompt_ids()
                                            print(f"Estilos disponibles: {estilos_disponibles}")
                                            
                                            # Si el estilo no existe, intentar encontrar una coincidencia por nombre
                                            if estilo not in estilos_disponibles:
                                                print(f"ADVERTENCIA: El estilo '{estilo}' no existe en el gestor de prompts.")
                                                
                                                # Intentar encontrar el estilo por nombre
                                                nombre_estilo = video_settings_del_job.get('nombre_estilo', '')
                                                if nombre_estilo:
                                                    # Mapa de nombres a IDs
                                                    nombre_a_id = {
                                                        'Cinematográfico': 'default',
                                                        'Terror': 'terror',
                                                        'Animación': 'animacion',
                                                        'imagenes Psicodelicas': 'psicodelicas'
                                                    }
                                                    
                                                    if nombre_estilo in nombre_a_id:
                                                        estilo = nombre_a_id[nombre_estilo]
                                                        print(f"Usando estilo '{estilo}' basado en el nombre '{nombre_estilo}'")
                                        except Exception as e:
                                            print(f"Error al verificar estilos: {e}")
                                        
                                        # Asegurarse de que el estilo sea un string válido
                                        if not estilo or estilo == "None" or estilo == "":
                                            estilo = "default"
                                        
                                        # Mostrar información detallada para depuración
                                        print(f"\n\n=== GENERACIÓN DE PROMPTS ===\n")
                                        print(f"Estilo seleccionado: '{estilo}'")
                                        print(f"Título del proyecto: '{job['titulo']}'")
                                        print(f"Nombre del estilo: '{job.get('nombre_estilo', 'No especificado')}'")                                        
                                        
                                        # Verificar que el estilo existe en el gestor de prompts
                                        try:
                                            from prompt_manager import PromptManager
                                            prompt_manager = PromptManager()
                                            estilos_disponibles = prompt_manager.get_prompt_ids()
                                            print(f"Estilos disponibles: {estilos_disponibles}")
                                            
                                            if estilo not in estilos_disponibles:
                                                print(f"ADVERTENCIA: El estilo '{estilo}' no existe. Usando estilo por defecto.")
                                                estilo = "default"
                                        except Exception as e:
                                            print(f"Error al verificar estilos: {e}")
                                        
                                        print(f"Estilo final utilizado: '{estilo}'\n")
                                        
                                        # Generar los prompts con el estilo seleccionado
                                        lista_prompts = generar_prompts_con_gemini(
                                            script_content,
                                            num_imagenes_necesarias,
                                            job['titulo'],  # <--- Pasar el título del proyecto
                                            estilo_base=estilo,
                                            tiempos_imagenes=tiempos_imagenes  # <--- Pasar la información de tiempos
                                        )

                                        if lista_prompts:
                                            job['prompts_data'] = lista_prompts
                                            job['num_imagenes'] = len(lista_prompts)
                                            prompt_file_path = Path(output_folder) / "prompts.txt"
                                            with open(prompt_file_path, "w", encoding="utf-8") as f:
                                                for p_idx, data in enumerate(lista_prompts):
                                                    f.write(f"--- Imagen {p_idx+1} ---\n")
                                                    f.write(f"Segmento Guion (ES):\n{data['segmento_es']}\n\n")
                                                    f.write(f"Prompt Generado (EN):\n{data['prompt_en']}\n")
                                                    f.write("="*30 + "\n\n")
                                            
                                            print(f"Prompts guardados en {prompt_file_path}")
                                            self.update_job_status_gui(job_id, "Prompts OK. Esperando Vídeo/Imágenes.")

                                            # --- Generación de Imágenes con Replicate ---
                                            try:
                                                if REPLICATE_AVAILABLE:
                                                    self.update_job_status_gui(job_id, "Generando imágenes...", "")
                                                    imagenes_generadas = []
                                                    image_output_folder = output_folder / "imagenes"
                                                    image_output_folder.mkdir(parents=True, exist_ok=True)

                                                    for idx, prompt_data in enumerate(lista_prompts):
                                                        prompt_en = prompt_data['prompt_en']
                                                        if prompt_en.startswith("Error"):
                                                            continue

                                                        self.update_job_status_gui(job_id, f"Generando imagen {idx+1}/{len(lista_prompts)}...", "")

                                                        img_filename = f"{output_folder.name}_{idx+1:03d}.png"
                                                        img_path = generar_imagen_con_replicate(prompt_en, str(image_output_folder / img_filename))

                                                        if img_path:
                                                            imagenes_generadas.append(img_path)
                                                            print(f"Imagen {idx+1} generada: {img_path}")
                                                        else:
                                                            print(f"Error generando imagen {idx+1}")

                                                    if imagenes_generadas:
                                                        job['imagenes_generadas'] = imagenes_generadas
                                                        self.update_job_status_gui(job_id, "Imágenes generadas OK", "")
                                                    
                                                    # Generar video final
                                                    try:
                                                        print(f"[{title}] Iniciando generación de video...")
                                                        self.update_job_status_gui(job_id, "Generando Video...", "")
                                                        
                                                        # Preparar argumentos para crear_video_desde_imagenes
                                                        video_settings = job.get('video_settings', {}).copy()
                                                        
                                                        # Asegurar que las rutas y parámetros esenciales estén presentes
                                                        video_settings['image_paths'] = [str(p) for p in imagenes_generadas]
                                                        video_settings['audio_path'] = str(final_audio_path)
                                                        
                                                        # Subtítulos si existen y están habilitados
                                                        if job.get('archivo_subtitulos') and job.get('aplicar_subtitulos'):
                                                            video_settings['subtitle_path'] = str(job['archivo_subtitulos'])
                                                        
                                                        # Limpiar None values
                                                        video_settings = {k: v for k, v in video_settings.items() if v is not None}
                                                        
                                                        print(f"[{title}] Llamando a crear_video_desde_imagenes...")
                                                        video_final_path = crear_video_desde_imagenes(
                                                            project_folder=str(output_folder),
                                                            **video_settings
                                                        )
                                                        
                                                        if video_final_path and os.path.exists(video_final_path):
                                                            print(f"[{title}] Video generado exitosamente en: {video_final_path}")
                                                            job['archivo_video'] = str(video_final_path)
                                                            job['tiempo_fin'] = time.time()
                                                            tiempo_total = job['tiempo_fin'] - job['tiempo_inicio']
                                                            tiempo_formateado = f"{int(tiempo_total // 60)}m {int(tiempo_total % 60)}s"
                                                            self.update_job_status_gui(job_id, "Video Completo", tiempo_formateado)
                                                        else:
                                                            print(f"[{title}] Error: No se generó el archivo de video")
                                                            job['tiempo_fin'] = time.time()
                                                            tiempo_total = job['tiempo_fin'] - job['tiempo_inicio']
                                                            tiempo_formateado = f"{int(tiempo_total // 60)}m {int(tiempo_total % 60)}s"
                                                            self.update_job_status_gui(job_id, "Error Video", tiempo_formateado)
                                                    
                                                    except Exception as e:
                                                        print(f"[{title}] Error en generación de video: {str(e)}")
                                                        traceback.print_exc()
                                                        job['tiempo_fin'] = time.time()
                                                        tiempo_total = job['tiempo_fin'] - job['tiempo_inicio']
                                                        tiempo_formateado = f"{int(tiempo_total // 60)}m {int(tiempo_total % 60)}s"
                                                        self.update_job_status_gui(job_id, f"Error Video: {str(e)[:50]}", tiempo_formateado)
                                                else:
                                                    self.update_job_status_gui(job_id, "Error generando imágenes", "")
                                            except Exception as e:
                                                print(f"Error generando imágenes con Replicate: {e}")
                                                self.update_job_status_gui(job_id, "Error generando imágenes", str(e))
            print(f"Error regenerando imágenes para {job_id}: {e}")
            traceback.print_exc()
            self.update_job_status_gui(job_id, f"Error: {error_msg}")
            return False